signals3 README

(c) 2013 helloworld922

Distributed under the Boost Software License, Version 1.0. (See
accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt)
=======================================================================

Signals/Slots implementation based off of atomic operations, with lock-free emits.

The target is to implement all features currently offered by Boost Signals2 while keeping lock-free emits.

Currently implemented towards the C++11 standard, but the goal is to eventually back-port to support C++03 using other Boost libraries.

Current dependencies:

- Boost Thread (mutex, unique_lock)*
- Boost Atomic (atomic boost::shared_ptr)*
- Boost shared_ptr/weak_ptr/make_shared*
- c++11 Variadic Templates
- c++11 std::function
- c++11 move semantics and lvalue refs
- boost move**
- c++11 tuple
- c++11 atomics
- c++11 forward_list
- c++11 std::forward
- boost optional

hopefully that's all of them.

*note:
Certain boost libraries are used because my current development platform doesn't support all c++11 features.
They are used in a manner which is consistent with the c++11 standard. You can take a look at signals3/detail/compiler_support.hpp and switch out appropriate components.

**note:
The actual code uses && for lvalue refs, and boost::move which binds to std::bind if compiler support is available.
Eventually I will find/replace with the appropriate Boost macro to get c++03 support.



======================
General Use
======================
The library is a header-only library unless boost::thread is used, which relies on boost::system which does have a compiled library.
See the boost documentation for how to build boost libraries.

Header file description:
	boost/signals3/signals3.hpp - main header file which gathers all header files
	boost/signals3/signal.hpp - definition for signal class
	boost/signals3/optional_last_value.hpp - optional_last_value combiner (basically the same as Signals2)
	boost/signals3/slots.hpp - definition for slot
	boost/signals3/connection.hpp - connection header file

For the most part including signals3/signals3.hpp will work. There are some slight interface differences:

- signal.operator() is now signal.emit
- signal.connect has been split into signal.push_front/signal.push_back
- connecting grouped slots is done using signal.insert and associated variants
- you can disconnect the first/last slot using signal.pop_front/signal.pop_back
- There are explicit thread unsafe handles of various functions. These have the same name as the thread-safe version, with an _unsafe at the end. For example: signal.emit_unsafe

keep in mind many features aren't quite implemented yet, and there may be many bugs. In other words, it's safe for testing and playing around with, but in general not ready for use.

-----------------------------------
Rational for interface name changes
-----------------------------------
Connect/disconnect names were changed to more closely reflect the terminology used by Standard Library containers.
Emit operation was changed from operator() to emit so that signals could be emitted unsafely using emit() or emit_unsafe.

Notable missing features:

- disconnect specific slot by passing a function/slot object.
- grouped slots (can insert, but currently no implementations for correctly removing these slots).
- no shared connection block (underlying details are implemented, just public handlers aren't available). It's possible to block/unblock any connection, though this might be changed in the future (I actually think this isn't possible in Signals2).
- connection/scoped_connection basically work, but may not have all the implementation details/work exactly like they do in Boost Signals2
- possibly other features

All handles reside in the boost::signals3 namespace.

====================
Design Goals
====================
The main design goal is observed by what signals/slots are typically used for:

1. Connecting/disconnecting slots is usually not that time critical.
2. Most signals either have no slots, or very few slots connected.
3. Signals may be invoked from multiple threads, and usually can be evaluated asynchronously. It seems like slots usually can be evaluated asynchronously, but they could be strongly ordered, too. In any case, only forward iteration is required for emitting a signal.
4. Emitting should be as fast as possible.

To solve this, the slots are tracked in a doubly-linked list which is always atomically a consistent singly linked list.
This allows for lock-free signal emit and a single writer (write operations typically must obtain a mutex).
Additionally, handlers have been added which allow for thread-unsafe operations which allow for external synchronization, or no synchronization at all if the signal will not be modified under general use.

The library is fully re-entrant, thread-safe* (with thread-unsafe handlers added), and type-safe.

*note: thread safety guarantee is similar to Boost Signals2 thread safety. For example, building a slot is not implemented in a thread-safe manner.
